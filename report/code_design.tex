\section{Code Design}
Summary of needs of the algorithm when looking at actual implementations not just mathematical description.
\vspace*{2cm} \\ 

Computing truly event-based optical flow would require the algorithm to operate on discerete events, evaluating the contribution of each and every one of them to optical flow field generated by all other ones.
It is infeaseble, since it would require unlimited memory and computational power.
We make the following simplifications.
Firstly, we quantize the spatio-temporal Gabor filter in time with a given time window and in space with a resolution equal to that of the DVS camera.
Tempoeral and spatial span of the filter is big enough to incorporate all points on which the filter's response is higher than some threshold value.
Such quantized filter comprises of discerte time-slices, which we call Filter Slices (FS).
Secondly, all events occuring in a single time window are grouped together or quantized into the so-called Event Slice (ES) and are assumed to have occured at the same moment, \emph{i.e.} the beginning of the time window. 
An ES is a square matrix, with the number of elements equal to that of the DVS camera. 
With this setup, computing optical flow means filtering the incoming stream of Event Slices with the previously set up filter.
A natural approach is to streamline the work, setting several components up in a pipeline.
Data comes into the pipeline and is processed sequentially by each of the compnents, leaving as a final product or optical flow in our case. 
Typically, data has to be read and post-processed.
This gives the final shape to our pipeline, as shown in figure \ref{fig:pipeline}, which consists of EventReader, Quantizer, FilteringEngine and FlowSink objects.
Since performance is our top priority, we aim for asynchronous execution of the steps with possibly parallel execution inside each of them.
This approach requires buffering of data between components, which we realize with blocking unbounded buffers.
\subsection{Overview Pipeline}
As our previous class diagram, as flow chart perhaps
\subsection{Convolution Engine}
Detailed look at the convolution engine idea??
\subsection{Other components}
Other Stuff??
